\documentclass[12pt,final]{article}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listing}
\usepackage{minted}
\usepackage{xspace}

\newcommand{\rust}[1]{\mintinline{rust}{#1}}

\newcommand{\rustname}{{\texttt Rust}}
\def \rust {\rustname{}\xspace}
\newcommand{\cname}{{\texttt{C}}}
\def \c {\cname{}\xspace}
\newcommand{\cppname}{{\texttt{C++}}}
\def \cpp {\cppname{}\xspace}
\newcommand{\mirname}{{\texttt MIR}}
\def \mir {\mirname{}\xspace}
\newcommand{\mlname}{{\texttt ML}}
\def \ml {\mlname{}\xspace}

\begin{document}
\title{Locality Optimizing Compiler Transforms in Rust}
\author{Jacob Bisnett}
\maketitle

\section{Introduction}
\label{sec:intro}

\paragraph{What is Rust}
% I don't want to talk about Rust forever,but if I need to say more I will
The programming language \rust is fairly new, but already gained a considerable
following due to its placement as a safe and easy to use alternative to \c and
\cpp. \rust's primary advantage is its robust compile time checks and type
system. Among many of these are:
preventing two mutable references to an object from existing at the same time, 
statically determining when to free objects without reference counting or
garbage collection,
and not allowing references to outlive their objects.
Taken all together, \rust helps the user avoid data races and memory safety
errors by preventing programs that could contain them from compiling.
\rust does allow users to circumvent these rules with ``unsafe'' code,
but this unsafety must be explicitly declared and thus dangerous behavior can be
isolated.

%maybe list companies using Rust? mozilla, amazon
While \rust is not the only language that provides this level of safety, it is
the only language that provides this level of safety with little to no overhead,
making it potentially as fast a \c and \cpp while avoiding many of the
pitfalls of the two languages. 
% source and table http://benchmarksgame.alioth.debian.org/u64q/rust.html



\paragraph{What is structure splitting}
% cite structure splitting paper.

\paragraph{How does structure splitting help}
General improvements

\paragraph{What solutions to structure splitting exist currently}
Ideally want a few more example here

\paragraph{How do they fail?}
Most of the time either the languages they use are not "safe" enough, ie have pointer arithmetic. 
%was there structure splitting done in Fortran

\paragraph{What does my solution do differently}

One of the major problems with
structure splitting is that most languages in which it would be beneficial to
implement it in have very weak safety guarantees, to the point that any
structure splitting approach would have an unacceptable effect on semantics, and
thus implementing structure splitting automatically would be a bad idea.

My solution doesn't have this issue because, since it's done in Rust unsafe behavior is very limited.

\subsection{Why Rust}
%https://tonyarcieri.com/it-s-time-for-a-memory-safety-intervention

\subsection{MIR}
%introducing mir: https://blog.rust-lang.org/2016/04/19/MIR.html
%mir rfc: https://github.com/rust-lang/rfcs/blob/master/text/1211-mir.md 

\section{Goals}
\label{sec:goal}

\begin{enumerate}
\item Opt-in
\item Semantically equivalent

\end{enumerate}

\section{Structure Splitting in Rust}

My approach to solving this problem was a series of compiler passes that, at a high level:
split Rust structs into some number of sub structures, modify function signature to accomidate this change,
and make edits to the \rust intermediate representation, called \mir, in order 
to actually perform the modifications.

\subsection{Structure Splitting}
Splitting \rust structs is the simplest part of the process. I made the decision to let the user decide
on how to split the struct. This is because I did not think that explicitly including automatic control would 
be very beneficial. This was for three main reasons. 

Firstly it was mandatory that the strategy used for structure splitting be modifiable by the user.
Since the structure splitting operation is so global and such a potential performance improvement,
some small change could end up resulting in massive performance gains or losses. Since it is impossible
to come up with a $100\%$ correct automated strategy, allowing a manual override is important, or else
user could potentially prevented from making important changes to their code since it could break the optimization.

Secondly, deciding how to split a structure is already a solved problem,
%cite structure splitting
but the process is rather expensive. It seems like a better idea to just allow the user to either; one, 
intelligently reason about there program and split their structure how it makes the most sense, or two, 
let them build an already existing tracing solution into their build system, and thus get the advantage
of deciding when and where to spend the computation time.

Thirdly, it is important that structure splitting be an ``opt-in" process. While \rust is by default
a memory safe language, \rust has an unsafety system that code allows for the same pointer arithmetic 
issues that \texttt{C} and other unsafe languages have. In \rust this unsafe code must be explicitly
declared, but exactly what unsafe code can do has yet to be fully defined. Thus forcing the user to explicitly 
turn structure splitting on, as well as reasoning about what it could mean for their program, is important.

\begin{enumerate}
\item Macros that split the struct
\item Change all arguments to functions and return values from Struct $\rightarrow$ (Struct1, Struct2, ...)
\item Extract the components of the tuple 
\item Change projections (struct.a) to their corresponding value (struct1.a)
\item Change wholesale struct assignments to assignments of the pieces 

struct = a;

To be

struct1 = a1;
struct2 = a2;

Split structs then exist in three types

Need to handle function signatures properly

\end{enumerate}

%poor phrasing, but need to eventually say this stuff somewhere.
There are multiple ways in which structs are represented in the MIR. 
\begin{enumerate}
\item Completely seperate: Not even part of the same tuple
\item Tupled: used for function args in the same crate
\item Fully reformed: used for passing function args to a different crate. (might change, might not even implement)
\end{enumerate}

\section{Discussion}
\label{sec:discuss}

This project is very much more of a platform for further research then a
standalone project. At the time of writing simple structure splitting
with arrays and references is all that is completed, and 
while I was successful is performing locality based
optimizations in that specific case without the usual run time overhead typical of structure splitting
work, there is considerably more work to be done until I would consider this
a project that should be usable by the average user.

\begin{figure*}
 \begin{minted}[autogobble]{rust}
    struct Mir {
        basic_blocks: Vec<BasicBlockData>,
        // ...
    }

    struct BasicBlockData {
        statements: Vec<Statement>,
        terminator: Terminator,
        // ...
    }

    struct Statement {
        lvalue: Lvalue,
        rvalue: Rvalue
    }

    enum Terminator {
        Goto { target: BasicBlock },
        If {
            cond: Operand,
            targets: [BasicBlock; 2]
        },
        // ...
    }
\end{minted} 
  \caption{Vec Splitting}
  \label{fig:vec-split}
\end{figure*}

The first, and most important, requirement would be to allow for the splitting
of certain types of user defined structures. The first, and most obvious,
benefit for this would be for allowing Vec, to be split as in Figure

\section{Issues}

While in common cases this approach works very well, there are a few issues with
it, most of which resulting from the fact that Rust does not have a languages
standard. As such, it is difficult to be certain that the compiler pass will
have no semantic effect on the code. It works within the current Rust
implementation, but manual testing can only be so successful.
% possibly cite the commit hash?

\subsection{Unsafety}
\label{sec:unsafe}


Another major issue is that, because there is no language standard, there is no
good way of dealing with unsafe code. Unsafe code allows for raw pointer
arithmetic, which breaks structure splitting. Rust does have the benefit that
unsafe code must be contained in explicitly declared code blocks.

\subsection{Rust Culture}
\label{sec:culture}

Rust, as opposed to one of it's parent language's \texttt{Haskell}, has no good
formal specification. The specification for \mir are practically non-existent. %https://github.com/rust-specification/english-specification
The closest thing there is are an RFC proposing \mir, and a blog post announcing
it, neither of which specify exactly what it can do, and both of which are now
out of date with the current implementation .

\section{Notes}
\label{sec:remove}

\subsection{Justification}
\label{sec:just}

\paragraph{Premonomorphization} Helpful for several reasons
\begin{enumerate}
\item Could lower compilation time by not having to regenerate code
\item  Easier to process in our particular case
\end{enumerate}

\paragraph{Shorter Compilation Times} One of the biggest sticking points for
Rust is that compilation times are quite long, in part due to LLVM taking
significant time in the compilation process (citation needed). Rust's safety
could potentially allow for excellent incremental compilation down to the basic
block level (citation needed). Additionally, LLVM takes a significant part of
Rust compilation times, and moving some optimization up from LLVM to Rust means
that other, faster backends can become for feasible. LLVM is also not
necissarily the best at compiling for certain architectures, such as WebASM.
With Rust getting WebASM as an alternate backend at some point, developing Rust
specific optimizations could be good.

%https://github.com/rust-lang/rust/issues/33205

\subsection{Rvalue Type induction}
Need to update the \texttt{AggregateKind::Array} so that it references the right Ty

\section{Challenges}
\label{sec:annoying}

\subsection{Deriving}
Most seem to be ok, but some combinations of derivations make things really
annoying, ie \texttt{Copy} and \texttt{Clone}.

\subsection{Polymorphism}

\subsection{User defined data structures}
Arrays are fine, but are difficult to use on their own. You really need to
handle Vectors, and Vectors are... complecated. Basically we needed to define a
trait, and users need to implement that trait on objects when it is safe to, ie
when it is stored in a ``dumb'' way, that doesn't semantically depend on the
contents of the object. This allows for potentially better cache behavior in
stuff such as HashMaps.


\end{document}